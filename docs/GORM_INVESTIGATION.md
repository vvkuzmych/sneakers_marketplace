# üîç GORM vs Raw SQL Investigation

**Date:** January 19, 2026  
**Current Approach:** Raw SQL with pgx/v5  
**Alternative:** GORM (Go Object-Relational Mapping)

---

## üìö –©–æ —Ç–∞–∫–µ GORM?

**GORM** - –Ω–∞–π–ø–æ–ø—É–ª—è—Ä–Ω—ñ—à–∏–π ORM –¥–ª—è Go, —è–∫–∏–π –∞–≤—Ç–æ–º–∞—Ç–∏–∑—É—î —Ä–æ–±–æ—Ç—É –∑ –±–∞–∑–∞–º–∏ –¥–∞–Ω–∏—Ö.

### GitHub Stats:
- ‚≠ê 35,000+ stars
- üì¶ Widely used in production
- üîÑ Active development
- üìñ Excellent documentation

### Supported Databases:
- PostgreSQL ‚úÖ
- MySQL
- SQLite
- SQL Server
- TiDB

---

## üÜö –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è: GORM vs Raw SQL (pgx)

### Current Approach (Raw SQL with pgx/v5)

#### ‚úÖ –ü–µ—Ä–µ–≤–∞–≥–∏:
1. **–ü–æ–≤–Ω–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å** –Ω–∞–¥ SQL –∑–∞–ø–∏—Ç–∞–º–∏
2. **–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å** - –Ω–µ–º–∞—î overhead
3. **–ü—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å** - –±–∞—á–∏—à —Ç–æ—á–Ω–æ —è–∫–∏–π SQL –≤–∏–∫–æ–Ω—É—î—Ç—å—Å—è
4. **–°–∫–ª–∞–¥–Ω—ñ –∑–∞–ø–∏—Ç–∏** - –ª–µ–≥–∫–æ –ø–∏—Å–∞—Ç–∏ JOINs, —Å—É–±–∑–∞–ø–∏—Ç–∏, CTEs
5. **–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è** - –º–æ–∂–Ω–∞ –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏ –∫–æ–∂–µ–Ω –∑–∞–ø–∏—Ç
6. **Debugging** - –ª–µ–≥–∫–æ –ª–æ–≥—É–≤–∞—Ç–∏ —ñ –∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ SQL
7. **pgx/v5** - –Ω–∞–π—à–≤–∏–¥—à–∏–π PostgreSQL driver –¥–ª—è Go

#### ‚ùå –ù–µ–¥–æ–ª—ñ–∫–∏:
1. **–ë–∞–≥–∞—Ç–æ boilerplate –∫–æ–¥—É** - Scan(), Query(), Exec()
2. **–†—É—á–Ω–∞ —Ä–æ–±–æ—Ç–∞** –∑—ñ Scan() –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø–æ–ª—è
3. **–ü–æ–º–∏–ª–∫–∏ –≤ runtime** - typos –≤ –Ω–∞–∑–≤–∞—Ö –ø–æ–ª—ñ–≤
4. **–î—É–±–ª—é–≤–∞–Ω–Ω—è –∫–æ–¥—É** - —Å—Ö–æ–∂—ñ –∑–∞–ø–∏—Ç–∏ –≤ —Ä—ñ–∑–Ω–∏—Ö –º—ñ—Å—Ü—è—Ö
5. **–°–∫–ª–∞–¥–Ω—ñ—à–µ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è** - –ø–æ—Ç—Ä—ñ–±–µ–Ω sqlmock
6. **–ú—ñ–≥—Ä–∞—Ü—ñ—ó** –≤—Ä—É—á–Ω—É –∞–±–æ —á–µ—Ä–µ–∑ –æ–∫—Ä–µ–º—ñ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏

---

## üéØ GORM Features

### 1. Auto Migrations
```go
// GORM —Å—Ç–≤–æ—Ä—é—î/–æ–Ω–æ–≤–ª—é—î —Ç–∞–±–ª–∏—Ü—ñ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
db.AutoMigrate(&User{}, &Product{}, &Order{})
```

### 2. Associations
```go
// –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω—ñ JOINs —ñ eager loading
db.Preload("Orders").Find(&user)
```

### 3. Hooks
```go
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // Auto-hash password
    u.Password = hashPassword(u.Password)
    return nil
}
```

### 4. Soft Deletes
```go
type User struct {
    DeletedAt gorm.DeletedAt // –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
}
```

### 5. Scopes
```go
func ActiveUsers(db *gorm.DB) *gorm.DB {
    return db.Where("is_active = ?", true)
}
```

---

## üìä Code Comparison

### Example: Get User By Email

#### Current Approach (Raw SQL + pgx):
```go
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*model.User, error) {
    query := `
        SELECT id, email, password_hash, first_name, last_name, phone,
               COALESCE(role, 'user') as role, 
               is_verified, is_active, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    user := &model.User{}
    err := r.db.QueryRow(ctx, query, email).Scan(
        &user.ID,
        &user.Email,
        &user.PasswordHash,
        &user.FirstName,
        &user.LastName,
        &user.Phone,
        &user.Role,
        &user.IsVerified,
        &user.IsActive,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err != nil {
        return nil, fmt.Errorf("failed to get user by email: %w", err)
    }
    
    return user, nil
}
```

**Lines:** 27  
**Manual Scan:** 11 fields  
**SQL:** Written manually

---

#### With GORM:
```go
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*model.User, error) {
    var user model.User
    if err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error; err != nil {
        return nil, fmt.Errorf("failed to get user by email: %w", err)
    }
    return &user, nil
}
```

**Lines:** 6  
**Manual Scan:** 0 (automatic)  
**SQL:** Generated by GORM

---

### Example: Create User

#### Current Approach:
```go
func (r *UserRepository) Create(ctx context.Context, user *model.User) error {
    query := `
        INSERT INTO users (email, password_hash, first_name, last_name, phone, is_verified, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id
    `
    
    err := r.db.QueryRow(
        ctx,
        query,
        user.Email,
        user.PasswordHash,
        user.FirstName,
        user.LastName,
        user.Phone,
        user.IsVerified,
        user.IsActive,
        user.CreatedAt,
        user.UpdatedAt,
    ).Scan(&user.ID)
    
    if err != nil {
        return fmt.Errorf("failed to create user: %w", err)
    }
    
    return nil
}
```

**Lines:** 27

---

#### With GORM:
```go
func (r *UserRepository) Create(ctx context.Context, user *model.User) error {
    return r.db.WithContext(ctx).Create(user).Error
}
```

**Lines:** 3  
**Auto-fill:** CreatedAt, UpdatedAt, ID

---

### Example: Complex Query with JOINs

#### Current Approach:
```go
func (r *OrderRepository) GetOrderWithDetails(ctx context.Context, orderID int64) (*model.OrderDetails, error) {
    query := `
        SELECT 
            o.id, o.order_number, o.buyer_id, o.seller_id,
            o.product_id, o.subtotal, o.total, o.status,
            o.created_at, o.updated_at,
            buyer.email as buyer_email, buyer.first_name as buyer_first_name,
            seller.email as seller_email, seller.first_name as seller_first_name,
            p.name as product_name, p.brand as product_brand
        FROM orders o
        JOIN users buyer ON buyer.id = o.buyer_id
        JOIN users seller ON seller.id = o.seller_id
        JOIN products p ON p.id = o.product_id
        WHERE o.id = $1
    `
    
    var details model.OrderDetails
    err := r.db.QueryRow(ctx, query, orderID).Scan(
        &details.ID, &details.OrderNumber, &details.BuyerID, &details.SellerID,
        &details.ProductID, &details.Subtotal, &details.Total, &details.Status,
        &details.CreatedAt, &details.UpdatedAt,
        &details.BuyerEmail, &details.BuyerFirstName,
        &details.SellerEmail, &details.SellerFirstName,
        &details.ProductName, &details.ProductBrand,
    )
    
    if err != nil {
        return nil, fmt.Errorf("failed to get order details: %w", err)
    }
    
    return &details, nil
}
```

**Lines:** 32

---

#### With GORM:
```go
type Order struct {
    ID        int64
    BuyerID   int64
    SellerID  int64
    ProductID int64
    Buyer     User    `gorm:"foreignKey:BuyerID"`
    Seller    User    `gorm:"foreignKey:SellerID"`
    Product   Product `gorm:"foreignKey:ProductID"`
    // ... other fields
}

func (r *OrderRepository) GetOrderWithDetails(ctx context.Context, orderID int64) (*model.Order, error) {
    var order model.Order
    err := r.db.WithContext(ctx).
        Preload("Buyer").
        Preload("Seller").
        Preload("Product").
        First(&order, orderID).Error
        
    return &order, err
}
```

**Lines:** 8  
**JOINs:** Automatic  
**N+1 Problem:** Solved with Preload

---

## üé® Model Definition Comparison

### Current (Raw SQL):
```go
type User struct {
    ID           int64     `json:"id"`
    Email        string    `json:"email"`
    PasswordHash string    `json:"-"`
    FirstName    string    `json:"first_name"`
    LastName     string    `json:"last_name"`
    Phone        string    `json:"phone"`
    Role         string    `json:"role"`
    IsVerified   bool      `json:"is_verified"`
    IsActive     bool      `json:"is_active"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

---

### With GORM:
```go
type User struct {
    ID           int64          `gorm:"primaryKey" json:"id"`
    Email        string         `gorm:"uniqueIndex;not null" json:"email"`
    PasswordHash string         `gorm:"not null" json:"-"`
    FirstName    string         `json:"first_name"`
    LastName     string         `json:"last_name"`
    Phone        string         `json:"phone"`
    Role         string         `gorm:"default:user" json:"role"`
    IsVerified   bool           `gorm:"default:false" json:"is_verified"`
    IsActive     bool           `gorm:"default:true" json:"is_active"`
    CreatedAt    time.Time      `gorm:"autoCreateTime" json:"created_at"`
    UpdatedAt    time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
    DeletedAt    gorm.DeletedAt `gorm:"index" json:"-"`
}
```

**Benefits:**
- Schema defined in code
- Constraints visible
- Soft deletes built-in
- Auto timestamps

---

## ‚ö° Performance Comparison

### Benchmarks (approximate):

| Operation | Raw SQL (pgx) | GORM | Overhead |
|-----------|---------------|------|----------|
| Simple SELECT | 0.05ms | 0.08ms | +60% |
| INSERT | 0.10ms | 0.15ms | +50% |
| UPDATE | 0.12ms | 0.18ms | +50% |
| Complex JOIN | 1.50ms | 1.80ms | +20% |
| Batch INSERT (100) | 5ms | 8ms | +60% |

**Conclusion:** GORM adds 20-60% overhead, but in most cases —Ü–µ –Ω–µ–∑–Ω–∞—á–Ω–æ (< 0.1ms)

---

## üß™ Testing Comparison

### Current Approach (sqlmock):
```go
func TestGetByEmail(t *testing.T) {
    db, mock, err := sqlmock.New()
    require.NoError(t, err)
    defer db.Close()
    
    rows := sqlmock.NewRows([]string{
        "id", "email", "password_hash", "first_name", "last_name", 
        "phone", "role", "is_verified", "is_active", "created_at", "updated_at",
    }).AddRow(1, "test@example.com", "hash", "John", "Doe", 
              "+123", "user", true, true, time.Now(), time.Now())
    
    mock.ExpectQuery("SELECT (.+) FROM users WHERE email").
        WithArgs("test@example.com").
        WillReturnRows(rows)
    
    repo := NewUserRepository(db)
    user, err := repo.GetByEmail(context.Background(), "test@example.com")
    
    require.NoError(t, err)
    assert.Equal(t, "test@example.com", user.Email)
}
```

**Lines:** ~20 per test

---

### With GORM (in-memory SQLite):
```go
func TestGetByEmail(t *testing.T) {
    db := setupTestDB(t) // SQLite in-memory
    
    // Create test user
    user := &User{Email: "test@example.com", FirstName: "John"}
    db.Create(user)
    
    // Test
    repo := NewUserRepository(db)
    found, err := repo.GetByEmail(context.Background(), "test@example.com")
    
    require.NoError(t, err)
    assert.Equal(t, "test@example.com", found.Email)
}
```

**Lines:** ~12 per test  
**Real DB:** Uses actual SQL queries (more reliable)

---

## üöÄ Migration Strategy (if we choose GORM)

### Phase 1: Add GORM alongside pgx (Hybrid)
```go
type UserRepository struct {
    db   *pgxpool.Pool  // existing
    gorm *gorm.DB       // new
}
```

### Phase 2: Migrate one service at a time
- Start with simplest service (User Service)
- Keep pgx for complex queries
- Use GORM for CRUD operations

### Phase 3: Gradual replacement
- Migrate repository methods one by one
- Keep backwards compatibility
- Comprehensive testing

---

## üìã GORM Example: User Repository

```go
package repository

import (
    "context"
    "gorm.io/gorm"
    "github.com/vvkuzmych/sneakers_marketplace/internal/user/model"
)

type UserRepository struct {
    db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository {
    return &UserRepository{db: db}
}

// Create creates a new user
func (r *UserRepository) Create(ctx context.Context, user *model.User) error {
    return r.db.WithContext(ctx).Create(user).Error
}

// GetByID retrieves a user by ID
func (r *UserRepository) GetByID(ctx context.Context, id int64) (*model.User, error) {
    var user model.User
    err := r.db.WithContext(ctx).First(&user, id).Error
    return &user, err
}

// GetByEmail retrieves a user by email
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*model.User, error) {
    var user model.User
    err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error
    return &user, err
}

// Update updates a user
func (r *UserRepository) Update(ctx context.Context, user *model.User) error {
    return r.db.WithContext(ctx).Save(user).Error
}

// Delete soft deletes a user
func (r *UserRepository) Delete(ctx context.Context, id int64) error {
    return r.db.WithContext(ctx).Delete(&model.User{}, id).Error
}

// List retrieves users with pagination
func (r *UserRepository) List(ctx context.Context, offset, limit int) ([]model.User, error) {
    var users []model.User
    err := r.db.WithContext(ctx).
        Offset(offset).
        Limit(limit).
        Order("created_at DESC").
        Find(&users).Error
    return users, err
}

// FindActive finds active users
func (r *UserRepository) FindActive(ctx context.Context) ([]model.User, error) {
    var users []model.User
    err := r.db.WithContext(ctx).
        Where("is_active = ?", true).
        Find(&users).Error
    return users, err
}
```

**Total Lines:** ~50 (vs ~200 with raw SQL)

---

## üí° Use Cases

### When GORM is GOOD:
‚úÖ CRUD operations (90% of queries)  
‚úÖ Standard relationships (1-to-many, many-to-many)  
‚úÖ Prototyping & MVP development  
‚úÖ Junior developers on the team  
‚úÖ Standard business logic  
‚úÖ Need rapid development  

### When Raw SQL is BETTER:
‚úÖ Complex analytics queries  
‚úÖ Performance-critical paths  
‚úÖ Complex JOINs with CTEs  
‚úÖ Database-specific features (PostgreSQL arrays, JSONB)  
‚úÖ Bulk operations (1000+ records)  
‚úÖ Database migrations  
‚úÖ When you need full control  

---

## üéØ Recommendation for Sneakers Marketplace

### Option 1: Stay with Raw SQL (Current) ‚úÖ

**Best for:**
- High performance requirements
- Team with strong SQL skills
- Complex business logic
- Full control needed

**Current Project Fit:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Excellent)
- Already established
- Good patterns in place
- Performance critical (marketplace)
- Complex queries (analytics, matching engine)

---

### Option 2: Hybrid Approach (GORM + Raw SQL)

**Use GORM for:**
- Simple CRUD (Users, Products, basic tables)
- Admin operations (low frequency)
- Prototyping new features

**Use Raw SQL for:**
- Matching engine (Bidding Service)
- Analytics queries (Admin Service)
- Order processing
- Performance-critical paths

**Best for:**
- Getting benefits of both
- Gradual learning
- Team flexibility

---

### Option 3: Full GORM Migration

**Best for:**
- Rapid development
- Simpler codebase
- Team less experienced with SQL
- Standard CRUD-heavy app

**Current Project Fit:** ‚≠ê‚≠ê‚≠ê (Medium)
- Might lose performance
- Complex queries harder
- Migration effort significant

---

## üìä Decision Matrix

| Criteria | Raw SQL (Current) | GORM | Hybrid |
|----------|-------------------|------|--------|
| Performance | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Development Speed | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Code Simplicity | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Flexibility | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Testing | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Learning Curve | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| Debugging | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Complex Queries | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |

---

## üéì Learning Resources

### GORM Documentation:
- https://gorm.io/docs/
- https://github.com/go-gorm/gorm

### Tutorials:
- GORM Quick Start
- GORM Associations
- GORM Transactions
- GORM Performance Tips

---

## üö¶ My Recommendation

### For This Project: **Hybrid Approach** üéØ

**Phase 1** (Low-Risk):
1. Add GORM to `go.mod`
2. Create GORM models alongside existing models
3. Try GORM in Admin Service (less critical)
4. Keep Bidding/Order services on Raw SQL

**Benefits:**
- ‚úÖ Learn GORM without risk
- ‚úÖ Keep performance where needed
- ‚úÖ Simpler code for simple operations
- ‚úÖ Best of both worlds

**Timeline:**
- Week 1: Add GORM, create example repo
- Week 2: Migrate Admin Service user management
- Week 3: Evaluate & decide next steps

---

## üíª Quick Start Example

```bash
# Add GORM
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres

# Create example repository
# internal/example/gorm_user_repository.go
```

---

## üìà Metrics to Track

If you decide to try GORM:

1. **Response Time:** Monitor latency increase
2. **Memory Usage:** GORM uses more memory
3. **Development Time:** Measure coding speed
4. **Bug Rate:** Track SQL-related bugs
5. **Code Lines:** Measure code reduction

---

## ‚úÖ Conclusion

**Current Approach (Raw SQL) is EXCELLENT for:**
- ‚úÖ Your marketplace (performance critical)
- ‚úÖ Complex matching engine
- ‚úÖ Learning SQL deeply
- ‚úÖ Full control

**GORM Would Help With:**
- ‚úÖ Faster development for simple CRUD
- ‚úÖ Less boilerplate
- ‚úÖ Easier testing
- ‚úÖ Built-in migrations

**My Final Take:**
**Keep Raw SQL as primary, try GORM for Admin Service to learn!** üéØ

You're already 80% done with Raw SQL, and it works great. Adding GORM for non-critical services gives you learning opportunity without risk!

---

**Next Steps if Interested:**
1. I can create a GORM version of User Repository
2. We can benchmark both approaches
3. You decide which you prefer!

Want to try? üòä
